## MDL Frontend  

**MDL::load_module\(IModule_cache \*, IInput_stream \*\)**  

> IMdl_compiler::load_module \[include/mi/neuraylib/imdl_compiler.h\]  
>>  
>> Mdl_compiler_impl::load_module \[src/api/api/mdl/mdl_mdl_compiler_impl.cpp\]   
>>>  
>>> Mdl_module::create_module \[src/io/scene/mdl_elements/mdl_elements_module.cpp\]   
>>>>  
>>>> MDL::load_module(IModule_cache *) \[src/mdl/compiler/compilercore/compilercore_mdl.cpp\]   
>>>>>  
>>>>> MDL::create_builtin_modules \[src/mdl/compiler/compilercore/compilercore_mdl.cpp\]   
>>>>>>  
>>>>>> **MDL::load_module\(IModule_cache \*, IInput_stream \*\)** \[src/mdl/compiler/compilercore/compilercore_mdl.cpp\]  
>>>>>>>  
>>>>>>> **Scanner** \#\#generated by **Coco/R** from **src/mdl/compiler/compilercore/compilercore_parser.atg**  
>>>>>>>  
>>>>>>> **Parser** \#\#generated by **Coco/R** from **src/mdl/compiler/compilercore/compilercore_parser.atg**  
>>>>>>>  
>>>>>>> Module::analyze \[src/mdl/compiler/compilercore/compilercore_modules.cpp\]   
>>>>>>>>    
>>>>>>>> NT_analysis::run \[src/mdl/compiler/compilercore/compilercore_analysis.cpp\]  
>>>>>>>>>    
>>>>>>>>> Module_visitor::visit \[src/mdl/compiler/compilercore/compilercore_visitor.cpp\]  
>>>>>  
>>>>> MDL::compile_module \[src/mdl/compiler/compilercore/compilercore_mdl.cpp\]  
>>>>>>  
>>>>>> **MDL::load_module\(IModule_cache \*, IInput_stream \*\)** \[src/mdl/compiler/compilercore/compilercore_mdl.cpp\]       

Scanner/Lex  
   
Regular Language //三型文法

RE(Regular Expression) // | () *  //可以参考FLex中的记法     
 ↓ Thompson's construction    
NFA(Nondeterministic Finite Automaton) //从某个状态出发，同一个字符可能对应多个不同的边（即产生不同的转移结果） //可能存在空字符对应的边(即空字符转换)，Thompson's construction会生成"空字符转换"         
 ↓ 幂集构造法(powerset construction)/子集构造法(subset construction)  //算法一定会终止 因为 设NFA的状态为n个 非空子集的个数不会超过$2^n-1$  
DFA(Deterministic Finite Automaton) //不同的终止状态对应Token的不同类型 //优化： DFA minimization    
  
DFA -> 转移表(translate table) //     

Parser/Syntax   
Context-Free Grammar //二型文法   
G = {N, T, P, S}  

产生式规则 //可以参考YACC中的记法

YACC约定 //Bison    
开始符号S 第一个产生式规则  
非终结符N 小写  
终结符T 大写  

BNF范式 //Coco/R  
非终结符N \<symbol\>  
终结符T $\underline{symbol}$  
  
给出结果 求推导过程(即 分析树) //可能产生不同的分析树 -> 二义性文法(比如 优先级) //文法重写 左递归文法(Expression Term Factor Atom)     
-> AST //开始符号S -> AST的根结点   

For example:  
exp-> n op n  
 n -> A  
 n -> B  
 n -> C  
 op -> E  
 op -> F  

LL(1)： 根据 当前的非终结符 和 1个前看符号(显然一定是终结符) 确定产生式规则  
//求出 每个产生式规则 对应的 所有可能的推导结果 的第1个符号(显然一定是终结符) 即First集  //通过比较 前看符号和First集 从而确定产生式规则  
//同一非终结符中 不同产生式规则的First集中 可能存在重复的符号 即LL(1)冲突 //仍有回溯的可能？  
//没有LL(1)冲突的上下文无关文法 称为LL(1)文法 //LL(1)文法 是 上下文无关文法 的特殊情形    

//First集 用不动点算法求解 //非终结符开头 比如 n->x y 有 First(n) = First(x)\[当x不可能为空串\] 如果x可能为空 需要求出First(y)以此类推 从而复用计算结果   
//Nullable集 可能为空串的非终结符 //如果 某条产生式规则 右侧 都是Nullable  那么 左侧的非终结符号 也是Nullable //可以用不动点算法求出Nullable集      
  
//整个上下文无法文法中 所有可能的推导结果 中 在某个非终结符之后的第1个符号(显然一定是终结符) 即Follow集   
  
//YACC: yytranslate_  


## libbsdf  
**LLVM_code_generator::load_and_link_libbsdf**  
  
We can mix MDL and C/C++ by converting them to the unified LLVM IR  
MDL -> LLVM IR  \#\#Frontend generated by Coco/R  
libbsdf(C/C++) -> LLVM IR  \#\#use c/c++ for better efficiency  \#\#generated by clang  
  
\#\#LLVM Bitcode: \#\# can be used as an asset    
clang -c -emit-llvm libbsdf.cpp -o libbsdf.bc \#\# optimaize options: -O2 -ffast-math -target x86_64-pc-win32    
  
\#\#LLVM Assembly Language:  
clang -S -emit-llvm libbsdf.cpp -o libbsdf.ll \#\#generated by clang  
llvm-dis libbsdf.bc -o libbsdf.ll \#\#generated by llvm-toolset    
  